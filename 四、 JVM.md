# 四、 JVM

## 1. JVM 的组成部分及其作用

- 类加载器：将 Java 代码转化为字节码
- 运行时数据区：将字节码加载进内存
- 执行引擎：解析字节码转化为系统指令
- 本地库接口：帮助将字节码转化为系统指令

## 2. JVM 运行时数据区

- 在 JDK 1.8 之前，包括：堆、方法区、虚拟机栈、本地方法栈、程序计数器
- 在 JDK 1.8 之后，将方法区进行了拆分，常量池放到了堆中，其他部分放到了直接内存中，成为元空间
- 堆：主要用来储存对象，GC 多发生于此
- 方法区：储存类信息、常量池、静态变量、即时编译后的代码等
- 虚拟机栈：用于储存当前线程中的局部变量、操作数、动态链接、方法出口等信息
- 本地方法栈：和虚拟机栈类似，但服务于本地方法
- 程序计数器：用于循环、跳转等代码的流程控制以及多线程切换判断运行到的位置

## 3. 双亲委派模型

- 原因：对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在 JVM 中的唯一性
- 实现：如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载
- 类加载器：
  - 启动类加载器（Bootstrap ClassLoader）：C++实现，在java里无法获取，负责加载/lib下的类
  - 扩展类加载器（Extension ClassLoader）： Java实现，可以在java里获取，负责加载/lib/ext下的类
  - 系统类加载器/应用程序类加载器（Application ClassLoader）：是与我们接触对多的类加载器，我们写的代码默认就是由它来加载，ClassLoader.getSystemClassLoader返回的就是它

## 4. 类加载的执行过程

- 加载：根据查找路径找到相应的 class 文件然后导入
- 检查：检查加载的 class 文件的正确性
- 准备：给类中的静态变量分配内存空间
- 解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址
- 初始化：对静态变量和静态代码块执行初始化工作

## 5. 怎么判断对象是否可被回收

- 引用计数法：维护一个计数器，当对象被引用时 +1，引用被释放时 -1，当计数器 = 0 时可被回收，但并不适用于循环引用
- 可达性分析法：从 GC Roots 开始搜索，走过的路径为引用链，当一个对象到 GC  Roots 没有任何引用链时，可被回收
  - 可被当做 GC Roots 的对象：虚拟机栈中引用的对象、类静态属性引用的变量、常量引用的变量、本地方法栈中引用的对象

## 6. 引用

- 强引用：不会被 GC
- 软引用：内存不足时会被 GC
- 弱引用：发现即被 GC
- 虚引用：发现即被 GC，需要配合引用队列使用

## 7. 垃圾回收算法

- 标记清除
- 标记整理
- 复制
- 分代

## 8. 垃圾收集器

- Serial：串行收集器，在收集垃圾的时候需要暂停所有其他工作线程
  - 复制+标记整理
- ParNew：Serial 的多线程版
- Parallel Scavenge：和 ParNew 相似，但更关注吞吐量（运行用户代码时间与 CPU 总消耗时间的比值）
- Serial Old：Serial 的老年代版本
- Parallel Old：Parallel Scavenge 的老年代版本
- CMS：获取最短回收停顿时间
  - 标记清除
  - 四个步骤
    - 初始标记：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 
    - 并发标记：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方
    - 重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
    - 并发清除：开启用户线程，同时 GC 线程开始对为标记的区域做清扫
  - 两次停机（STOP THE WORLD）:发生在初始标记和重新标记
- G1 ：针对服务器

## 9. 完整的 GC 流程

- 对象先被分配到 Eden
- 当 Eden 满了的时候进行一次 Minor GC，将 Eden 和 Surviver From 中的存货对象移到 Surviver To
- 互换 Surviver From 和 To 的身份
- 撑过一次 Minor GC，对象的年龄就会增加一岁，当对象到达 15 岁，或者Survivor From 中的对象超过一半都等于某个岁数，那么超过这个岁数的所有对象，都会被放入老年代
- 当加入老年代的对象超过老年代剩余空间时，引发 Full GC

## 10. JVM 调优工具

- jconsole：用于对 JVM 中的内存、线程和类等进行监控
- jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等