# 八、 MySQL

## 1. 数据库的三范式

- 1NF：字段不可分，原子性，字段不可再分，否则就不是关系数据库
- 2NF：有主键，非主键字段依赖主键，唯一性，一个表只说明一个事物
- 3NF：非主键字段不能相互依赖，每列都与主键有直接关系，不存在传递依赖

## 2. 自增主键删除后的下一个主键值

- 如果当前表中有 17 条数据，删除两条后，直接添加一条，那么 id 为 18
- 若重启
  - InnoDB 会丢失最大 ID，因为它只把最大 ID 记录在内存中，所以添加一条 id 为 16
  - MyISAM 不会丢失最大 ID，因为它把最大 ID 记录在文件中，所以添加一条 id 为 18

## 3. 如何获得当前数据库版本

- select version()

## 4. ACID 是什么

- Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简
- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

## 5. char 和 varchar 的区别

- char：定长字符串，不足长度用空格补充
- varchar：不定长字符串
- char 的效率比 varchar 高

## 6. float 和 double 的区别

- float 最多可以存储 8 位的十进制数，并在内存中占 4 字节
- double 最可可以存储 16 位的十进制数，并在内存中占 8 字节

## 7. 内连接、左连接、有连接的区别

- 内连接：两张表都有的
- 左连接：左边没有的但右边有的显示为 null
- 右连接：右边没有的但左边有的显示为 null

## 8. MySQL 索引

- B+ 树实现，原因为会出现 WHERE id < 6，这样的查询，hash 会进行全表扫描，红黑树由于其树高不定，也类似于全表扫描
- 分类：
  - 普通索引 index
  - 唯一索引
    - primary key：主键，不空且唯一，更多是约束
    - unique：唯一
  - 联合索引
    - primary key(id, name)：联合主键索引
    - unique(id, name)：联合唯一索引
    - index(id, name)：联合普通索引
  - 全文索引 fulltext：用于搜索文章
  - 空间索引 spatial：不常用
- 最左前缀规则：索引会按照从左到右的顺序匹配
- 无法命中索引的情况：
  - like '%xx'
  - 使用函数 reverse(email) = 'xxx'
  - 类型不一致，比如如果要命中字符串类型索引，需要在判断条件中加入双引号

## 9. 事务隔离

- READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）
- READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）
- REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）
- SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读
- 脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A
- 不可重复读 ：是指在一个事务内，多次读同一数据，其他事物提交修改后，会发现两次读的结果不一样
- 幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了

## 10. 引擎

- InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的
- MyIASM 引擎：不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选

## 11. 锁

- 行锁：开销大，加锁慢，会产生死锁，并发度高
- 表锁：开销小，加锁快，不会产生死锁，并发度低
- 页锁：两者之间

## 12. 性能优化

- 为搜索字段创建索引
- 避免使用 select *，列出需要查询的字段
- 水平、垂直分割分表
- 选择正确的存储引擎
- 尽量对字段加 NOT NULL 约束