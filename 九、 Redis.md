# 九、 Redis

## 1. Redis 是什么以及有哪些使用场景

- key-value 数据库
- 基于内存，但可以持久化
- 常用作缓存

## 2. Redis 和 Memecache 的区别

- redis 支持多种数据类型，memecache 只支持字符串
- redis 支持持久化，memecache 不支持

## 3. Redis 为什么那么快

- 完全基于内存，数据储存在内存中，结构类似于 HashMap，操作的时间复杂度为 O(1)
- 数据结构简单，操作也简单
- 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
- 使用多路复用 IO，非阻塞 IO
  - 多个网络连接复用一个线程，IO 流空闲时，线程阻塞，事件来临时，会轮询所有流，并只处理就绪的流

## 4. Redis 为什么是单线程的

- 官方 FAQ 表示，因为 Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了
- 虽然是单线程的，不代表不可以通过启动多个实例的方式支持多核 CPU，采用主从模式，将耗时的读命令放到从服务器中

## 5. Redis 怎么实现分布式锁

- 使用 setnx （SET IF NOT EXIST）指令，只允许一个变量被一个程序占有，使用完后 del 释放

## 6. Redis 淘汰策略

- volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
- no-enviction（驱逐）：禁止驱逐数据

## 7. Redis 持久化有几种方式

- Redis 的持久化有两种方式，或者说有两种策略：
  - RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储
  - AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中

## 8. 缓存雪崩

- 原有缓存失效(过期)而新缓存未到期间，所有请求都去查询数据库，对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃
- 解决方法：
  - 设置缓存时间的时候加入随机因子
  - 并发量不是特别高的情况下，可以采用加锁排队的方式，减轻数据库压力
  - 给缓存增加缓存标记，判断缓存是否失效了，若缓存时效，可以交由另一个线程去从数据库更新缓存。标志位失效的时间可以设置成缓存失效时间的一半，这样在更新缓存的过程中还是可以返回旧的缓存供使用

## 9. 缓存穿透

- 用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空，这样请求就绕过缓存直接查数据库，可能会被恶意攻击
- 解决方法：
  - 将查询为空的值也加入缓存
  - 预先将空键赋值
  - 预先对一些数据进行过滤处理

## 10. 缓存击穿

- 一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个 key 在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库
- 解决方法：
  - 预先设为永不过期